# A New Language Is Born... Say Hello to Crypt!

OK... It's been sometime since I last posted, but that's because the time was spent trying to fix an old language, getting frustrated, and creating a new one. If you are wondering what I am talking about, the old language is the one I created, called [Cylvre](https://github.com/Cylvre-Language/Cylvre). In my last post, I described how I was thrust upon the adventure that was [Creating a Programming Language](https://aurumbyte.github.io/Posts/Creating%20Cylvre), and in this post I plan on telling you how I got frustrated with the result. So... stick around if you wish to know about my suffering with Cylvre, and how I got over it to create the successor to it (somewhat), i.e. [Crypt](https://github.com/Crypt-Language/Crypt)

## First... My Pains

Yes... I developed a language. Yes... I said I would stick with it and not give up, but, if you were me, you would be running away and wishing compilers never existed. So, here are my pains:

 - Turns out the compiler I "created" (copied and tweaked) had too many problems. Every fix I made resulted in a sea of NPEs. Every other NPE fix resulted in more problems.
 - The compiler wasn't really mine, and so adding new features became an absolute pain in the brain. Any features I did add were buggy anyway. 

So, I terminated development for Cylvre.

# Ok, Now what ?

After I archived the repository, I was still thinking about how good it would be if I developed a language that would fit my needs. Also, I was pretty disappointed about giving up on Cylvre, and I wanted to make up for it.

As I was sitting there, brainstorming new syntax ideas for my next language, Crypt, I was suddenly struck with an idea. Cylvre's compiler structure meant that when a visitor visits a `ruleContext`, It returns a value of type `SomeStatementClass` which is then passes to `SomeStatementClassGenerator` which generates the bytecode and sends the finished product to the compiler to write to a `.class` file.

My problem with this is... it's way to many files. Fine, it may be more "modular", perhaps even easier to maintain, but it also meant searching for the cause of a problem in multiple files and still coming up with nothing (This contradicts the easier to mainatin bit). Also, most of the node classes barely crossed the 100 LOC limit (*Remember the sea of NPEs? Imagine trying to find the cause for it in over 100 files. Happy now?  I didn't think so.*).

So... yeah, back to the idea. My solution for this was to handle the visiting and the bytecode generation for a statement in the same file/class. This cuts 50% of the code/files required and puts all the aspects of the compiler in one place. Now, if an error occurs, I'll know where to look. I also did some Googling to find if anyone had attempted it before me and nope... not a single result. Seems like I'm the only one who thought of this (or maybe had the guts to try it). Do tell me if I'm wrong, I'd be surprised I didn't find it earlier.

So, I decided to recycle most of the syntax ideas of Cylvre (there were some really good syntax ideas in there) and set off to research and see if my idea would work.

As for the implementation itself, I wanted ANTLR's visitor to automatically visit a ruleContext while the file was parsed for my idea to work. A quick [StackOverflow question](https://stackoverflow.com/questions/66613957/can-antlrs-visitor-system-automatically-visit-a-rule-context-when-a-file-is-pars) later I validated my idea and set off on the long journey that was the implementation itself.

# The Implementation Process

 - First, I made the compiler class that would actually compile the files and write the generated bytecode to a `.class` file. For this, I tweaked on the Cylvre compiler class because it was handy and all it needed were a few changes to work with my idea.
 
 - Now for the bytecode generation. I started by writing the `FileBuilder` which then was linked to the compiler. From there, I worked backwards, writing any `builder` files I needed for Crypt's `ruleContexts` (including `StatementBuilder`, `ExpressionBuilder` and related). The `builder` files roughly followed the below structure :
 
```java
public SomeStatementBuilder extends SomeLanguageBaseVisitor<Void> {
  // some fields for data handling

  @Override
  public Void visitSomeStatement(@NotNull SomeStatementContext ctx){
    //visitor code goes here
    
    buildStatement(/*Arguments if parameters are there (possibly SomeStatementContext)*/);
  }
  
  public void buildStatement(/*Parameters (if needed)*/){
    //bytecode generation for someStatement here
  }
}
```

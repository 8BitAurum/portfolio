# A New Language Is Born... Say Hello to Crypt!

#### -- 5th April 2021 

OK... It's been sometime since I last posted, but that's because the time was spent trying to fix an old language, getting frustrated, and creating a new one. If you are wondering what I am talking about, the old language is the one I created, called [Cylvre](https://github.com/Cylvre-Language/Cylvre). In my last post, I described how I was thrust upon the adventure that was [Creating a Programming Language](https://aurumbyte.github.io/Posts/Creating%20Cylvre), and in this post I plan on telling you how I got frustrated with the result. So... stick around if you wish to know about my suffering with Cylvre, and how I got over it to create the successor to it (somewhat), i.e. [Crypt](https://github.com/Crypt-Language/Crypt)

## First... My Pains

Yes... I developed a language. Yes... I said I would stick with it and not give up, but, if you were me, you would have given up the moment the compiler came out with loads of NPEs at its tail. So, here are my pains:

 - Turns out the compiler I "created" (copied and tweaked) had too many problems. Every fix I made resulted in a sea of NPEs. Every other NPE fix resulted in more problems.
 - The compiler wasn't really mine, and so adding new features became an absolute pain in the brain. Any features I did add were buggy anyway.
 - I wanted to start over and make the compiler **my way**, not spend my time wrapping my head around concepts just to find out how to add/fix a feature in the compiler. 

So, I terminated development for Cylvre.

# Ok, Now what ?

After I archived the repository, I was still thinking about how good it would be if I developed a language that would fit my needs. Also, I was pretty disappointed about giving up on Cylvre, and I wanted to make up for it.

As I was sitting there, brainstorming new syntax ideas for my next language, Crypt, I was suddenly struck with an idea for a compact compiler. "What do you mean?" you ask? Well... Let me tell you.

Cylvre's compiler structure meant that when a visitor visits a `ruleContext`, It returns a value of type `SomeStatementClass` which is then passed to `SomeStatementClassGenerator` which generates the bytecode and sends the finished product to the compiler to write to a `.class` file.

My problem with this is... it's way to many files. Fine, it may be more "modular", perhaps even easier to maintain, but it also meant searching for the cause of a problem in multiple files and still coming up with nothing (This contradicts the easier to mainatin bit). Also, most of the node classes barely crossed the 100 LOC limit, so most of the time, I was searching for the source of a problem (or just a bit of code) in multiple files of around 30 - 70 LOC (*Remember the sea of NPEs? Imagine trying to find the cause for it in over 100 files. Happy now?  I didn't think so.*).

So... yeah, back to the idea. My solution for this was to handle the visiting and the bytecode generation for a statement in the same file/class. This cuts 50% of the code/files required and puts all the aspects of the compiler in one place. Now, if an error occurs, I'll know where to look. I also did some Googling to find if anyone had attempted it before me and nope... not a single result. Seems like I'm the only one who thought of this (or maybe had the guts to try it). Do tell me if I'm wrong, I'd be surprised I didn't find it earlier.

So, I decided to recycle most of the syntax ideas of Cylvre (there were some really good syntax ideas in there) and set off to research and see if my idea would work.

As for the implementation itself, I wanted ANTLR's visitor to automatically visit a ruleContext while the file was parsed for my idea to work. A quick [StackOverflow question](https://stackoverflow.com/questions/66613957/can-antlrs-visitor-system-automatically-visit-a-rule-context-when-a-file-is-pars) later I validated my idea and set off on the long journey that was the implementation itself.

# The Implementation Process

 - First, I made the compiler class that would actually compile the files and write the generated bytecode to a `.class` file. For this, I tweaked on the Cylvre compiler class because it was handy and all it needed were a few changes to work with my idea.
 
 - Now for the bytecode generation. I started by writing the `FileBuilder` which then was linked to the compiler. From there, I worked backwards, writing any `builder` files I needed for Crypt's `ruleContexts` (including `StatementBuilder`, `ExpressionBuilder` and related). The `builder` files roughly followed the below structure :
 
```java
public SomeStatementBuilder extends SomeLanguageBaseVisitor<Void> {
  // some fields for data handling

  @Override
  public Void visitSomeStatement(@NotNull SomeStatementContext ctx){
    //visitor code goes here
    
    buildStatement(/*Arguments if parameters are there (possibly SomeStatementContext)*/);
  }
  
  public void buildStatement(/*Parameters (if needed)*/){
    //bytecode generation for someStatement here
  }
}
```
First, all I needed my language to do is to print to the console, so I built the compiler accordingly, whilst also keeping it modular to easily add more features in later.

Since I built the compiler on my own, the ride was slightly bumpy yet manageable. I got the compiler working smoothly very quickly and started testing and... immediately ran into an issue. The compiler works... but the problem was that I needed to rebuild the `ExpressionBuilder` because `println();` was failing to recognise the expression passed as an argument.

As of this writing, this is where the compiler stands. Crypt is currently undergoing some major development and is by no means a Turing-complete programming language yet, but it will get there sometime in the future (by sometime in the future I mean like a couple of weeks maybe months but not years).
